📌 __**연관관계 매핑**__
======================
> 테이블은 외래 키로 조인을 사용해서 연관되 테이블을 찾는다. 객체는 참조를 사용해서 연관된 객체를 찾는다. 
> 테이블과 객체 사이에 차이가 존재하기 때문에 객체의 참조와 테이블의 외래 키를 매핑해주어야 된다.

**1. 단방향, 양방향**
---------------------------
  > - 테이블 : 외래 키 하나로 조인이 가능 , 방향이라는 개념이 없고 두 테이블에서 양쪽을 검색할수 있다.
  > 
  > - 객체 : 참조용 필드가 있는 쪽에서만 참조가 가능, 한쪽만 참조하면 단방향, 양쪽이 서로 참조하는 필드가 있으면 양방향
  
**2. 연관 관계 주인**
-----------------------
   > **주로 양방향**에서 이루어지며, 테이블은 **외래 키 하나** 로 두 테이블의 연관관계를 맺는다.
   > 객체 양방향 관계는 A->B, B->A처럼 2군데 참조가 가능하니 둘중 테이블의 외래 키를 관리할 곳을 지정해야 된다.
   > **1:N** 에서 N(다)에 외래 키를 보통 위치 시키며 N에 해당하는 객체의 필드중 참조값을 주인으로 보통 지정한다.
   
   * 연관관계의 주인
     > 외래 키를 관리하는 역할(등록, 수정등), **@JoinColumn(name ="?")** 을 통해서 join할 테이블의 칼럼명을 지정한다.
     > 외래 키가 존재하는 객체를 주인으로 정함, 주인은 "mappedBy"속성을 사용하지 않는다.

   * 주인의 반대편
     > 외래 키에 영향을 주지 않는다.(등록, 수정이 DB에 반영되지 않는다) 
     > 단순 조회만 가능하다. **mappedBy**속성으로 주인을 지정해준다.
----------------------------------------------
__[예시 - 양방향 매핑]__

![image](https://user-images.githubusercontent.com/96917871/178513956-9ee859ed-02dd-418e-8bb5-2a6ac2f8f397.png)
```
@Entity(name = "testMember")
@Data
public class Member {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "member_id")
    private Long id;
    private String username;

    @ManyToOne
    @JoinColumn(name = "team_id")
    private Team team;

public class Team {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name ="team_id")
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    List<Member> members = new ArrayList<>();
}
```   
- "Member" 객체 필드에서 "team"객체를 참조(Team team)가 가능하고 "Team"객체 필드에서 "Member"객체를 참조(List<Member> members)가능하기 때문에 **양방향**
- N에 해당하는 "Member"객체에 외래값 즉 주인으로 설정한다. -> **@JoinColum(name="")** 으로 조인할 테이블의 칼럼명을 정의
- 주인이 아닌 "Team"객체는 **@mappedBy** 로 참조하는 필드명으로 지정하고 단순히 값(members)만 조회가 가능하지 등록,수정하여도 DB에 반영되지 않음  

    
**[❗주의]**
- **양방향 매핑시 연관관계의 주인에 값에 입력하거나 수정해야 한다.!! 해당 데이터가 DB에 반영된다.(JPA가 SQL문에 값을 넣어 반영해줌), DB에 입장에서는 "FK"를 바꾸는 작업**
- **주인이 아닌 필드에 값을 넣거나 수정하면 DB에 반영되지 않는다.!!**
- 객체지향적인 관계를 고려하여 주인이 필드와 주인이 아닌 필드에 값을 모두 넣는것이 객체지향에 더 부합한다. -> 객체에 측면에서 양쪽의 참조의 값을 찾을수 있다.!! 
  
-------------------------------------------------- 
  
**3. 다중성**
--------------------------
   * 다대일 [N:1]
     > 가장 흔한 연관관계, 외래키가 있는 쪽(N쪽)을 연관관계 주인으로 설정
     >
     > "@ManyToOne" + @"JoinColumn" 으로 조인할 테이블의 컬럼명을 설정(단방향), "OneToMany(mappedBy="")"으로(양방향) 주인이 아닌 단순히 참조할 필드명 설정
   
   * 일대다 [1:N]
     > 테이블에서 N쪽에 외래키가 있고 , 연관관계 주인을 일쪽에 두는 방식
     >
     > "@OneToMany" +  @"JoinColumn"으로 조인할 테이블의 컴럼명을 설정(당방향)
   
   * 일대일 [1:1]
     > 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
     > 
     > 다대일 양방향 매칭 처럼 외래 키가 있는 곳이 연관관계의 주인, 반대편은 mappedBy 적용
     >
     > ![image](https://user-images.githubusercontent.com/96917871/178520839-7c206154-deea-440f-b319-1286eea46919.png)

   * 다대다 [N:M]
     > 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 함 , 사용하지 말기!!
  
  
  
➕ __**고급 매핑(상속 관계 매핑)**__
======================
> 관계형 DB에는 상속관계가 존재하지 않음. 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
* 중요 어노테이션
   * @Inheritance(strategy = IngeritanceType.XXX)
     * JOINED : 조인 전략
     * SINGLE_TABLE: 단일 테이블 전략
     * TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
  
   * @DiscriminatorColumn(name="DTYPE")
     > 슈퍼타입 테이블의 서브 타입의 명을 자동으로 넣어주는 애노테이션. 
     > 부모클래스에 정의하며 자식클래스를 등록하게 되면 기본적으로 슈퍼타입 테이블의 컬럼(DTYPE)에 자식클래스의 정의 이름으로 값이 들어가게 된다. 
  
**1. 각각 테이블로 변환 -> 조인 전략**
  > ![image](https://user-images.githubusercontent.com/96917871/178696288-527a748c-f319-44fe-b8c2-8cbab622ed9e.png)
  > 
  > 부모,자식클래스의 테이블이 생성되고, 상속관계인 자식클래스를 "persist"하면 자동으로 2테이블의 값이 들어가진다. 또한 조회할때 자동으로 "join"해준다. 
    
**2. 통합 테이블로 변환 -> 단일 테이블 전략**
  > ![image](https://user-images.githubusercontent.com/96917871/178701522-b649a72b-5836-4646-9cde-7e3e1216a70c.png)
  > 
  > 자식클래스의 속성을 모두 가지고 있는 부모클래스의 테이블이 하나만 생성되고, 자식 클래스를 "persist"하게되면 값이 들어가진다.
  > 자동으로 "@DiscriminatorColumn(name="DTYPE")"의 옵션을 가지고 있다.
  
**3. 서브타입 테이블로 변환 -> 구현 클래스 마다 테이블 전략**
  > 사용하지 말기.
  

  
➕ __**@MappedSuperclass**__
======================
> 테이블과 관계 없고 단순히 엔티티가 공통으로 사용한는 매핑 정보를 모으는 역할
> 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용.
>
> 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공. 부모클래스로 조회,검색 불가능. 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장
  
  







