__📌영속성 컨텍스트__
--------------------------
> 내부에 1차 캐시, 쓰기 지연 SQL저장소로 이루어짐
- 영속성 컨텍스트는 논리적인 개념 엔티티 매니저를 통해서 영속성 컨텍스트에 접근(같은 의미라고 생각해도 무방)
- 엔티티 메니저와 영속성 컨텍스트의 관계가 1:1 ,N:1로 존재할수 있다.

1. **엔티티의 생명주기**
   * 비영속
     >영속성 컨텍스트가 관리하지 않는 관계 없는 상태, 영속성 컨텍스트 기능 사용 불가
   * 영속 
     > 영속석 컨텍스트가 관리하는 상태, 영속성 컨텍스트가 제공하는 기능을 사용할수 있다.
   * 준영속 
     > 영속성 컨텍스트가 관리하다가 분리된 상태
     > 영속성 컨텍스트 기능 사용 불가 , **변경 감지**와 같은 기능을 사용하지 못한다.
   * 삭제 - 삭제된 상태

2. **영속성 컨텍스트의 이점**
   * 1차 캐시
     > "persist"메소드는 DB에 쿼리문을 날리는 것이 아니라 엔티티를 영속컨텍스트로 넣는 행위이며 1차 캐쉬에도 저장된다. 
     > 또한 "find" 메소드는 먼저 영속컨텍스트의 1차 캐시에서 엔티티를 찾게 되고 없을 시 DB에서 캐시로 앤티티를 올린다.
     > 1차 캐쉬를 통해 쿼리문을 줄일수 있다.
   
   * 동일성 보장
     > 같은 트랜잭션내에서 같은 객체는 동일한 객체를 보장한다.

   * 쓰기 지연
     > 모든 엔티티 변경시에는 트랜잭션을 통해서 이루어져야 된다. "persist"메소드가 호출될때 DB로 SQL문을 보내지 않는다.
     > 영속성 컨텍스트를 flush + commit할때 실제 "쓰기 지연 SQL저장소"에 있는 SQl문이 DB로 전달된다. (트랜잭션 커밋은 2기능을 포함)
   
   * 변경 감지
     > ![image](https://user-images.githubusercontent.com/96917871/178145776-9a26e009-814e-43b9-a44a-6f9793bbb9c6.png)
     > 
     > "find"를 통해 1차 캐시,DB(1차 캐시에 없을시 SQL문나감)에서 찾은 엔티티를 수정한 후 **트랜잭션 커밋**을 만나게 되면 1차 캐시의 스냅샷과 엔티티를 비교하여 
     > **변경**이 있으면 SQL저장소에 자동으로 Update 쿼리문이 들어가게 되고 flush+commit으로 DB에 전달된다.

   * 지연 로딩
     >!!!!!
     >!!!!!

3. 플러시
   > 영속성 컨텍스트를 비우는 것이 아니라 DB와 동기화를 맞추는 작업
   > 트랜잭션 작업 단위가 중요한 개념이다. 트랜잭션 커밋 직선에만 동기화 하면됨
   
   * 플러시되는 경우
     * 직접 호출 - em.flush()
     * 트랜잭션 커밋 - 영속성 컨텍스트 flush + commit 자동 호출
     * JPQL 쿼리문 - 플러시 자동 호출


