📌**프록시**
==========================
> ![image](https://user-images.githubusercontent.com/96917871/178739538-1c66ab0e-c996-4504-b9ca-5e6e2ba4ab51.png)
> * 실제 클래스를 상속 받아서 만들어짐, 실제 클래스와 겉모양이 같다.
> * 프록시 객체는 실제 객체의 참조를 보관하고 있다. ,프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드 호출

* 프록시 객체의 초기화
  > ![image](https://user-images.githubusercontent.com/96917871/178740019-cb47afa2-ad08-44c1-b4bd-4c16487e5140.png)
  > 
  > * "getReferenct"메소드를 통해 **프록시객체**를 만들어 반환하게 된다., 처음 생성된 프록시는 **target**이 null이 된다.
  > * 실제로 프록시의 속성값을 사용할때 프록시는 **영속성 컨텍스트**에 **초기화 요청**을 보내게 된다. **초기화 요청**을 하게 되면 영속성 컨텍스트에서 객체를 찾게 되고 없으면 
  > DB를 찾아 실제 엔티티를 생성한 후 프록시의 **target**에 연결한다.!!

* 프록시의 특징
  > * 프록시 객체는 처음 사용할 때 한번만 초기화 된다.
  > * 초기화가 되면 프록시 객체가 실제 엔티티로 바뀌는것이 아니라!! "target"에 연결되어 프록시 객체를 통해서 실제 엔티티에 접근하는 것이다.
  > * 프록시 객체는 원본엔티티를 상속받아 생성되기 때문에 타입 체크에 주위
  > * **초기화** 요청을 하게 되면 **영속성 컨텍스트**에서 객체를 해당 객체를 찾게 되는데 만약 이미 존재한다면 프록시 객체가 생성되는 것이 아니라 **원본 객체**를 반환해준다.
  > * 영속성 컨텍스트가 관리하지 않는 상태(준영속등)일때 프록시를 초기화하면 에러 발생 -> 초기화는 영속성 컨텍스트를 통해서 이루어 지기 때문



📌**즉시로딩, 지연로딩**
================================
> "@ManyToOne", "@OneToOne"등 객체의 연관관계 매핑에서 한 객체내에 다른 객체를 참조하고 있는 상황에서 다른 객체를 품고있는 객체를 불러왔을때 품고 있는 객체를 "실제객체","프록시객체"로 가져오는 로딩 방법

* **즉시 로딩**
  > ![image](https://user-images.githubusercontent.com/96917871/178743168-3390a825-a8cb-40be-b751-47de9ad06003.png)
  > * 하나이상의 객체를 품고 있는 객체를 로딩할때(get) 품고있는 객체들도 실제 객체로 같이 로딩한다. 조회할때 두 객체에 대해서 한번에 JPA가 SQL문을 만들어 DB에 전송 
  > * ManyToOne(fetch = FetchType.EAGER)"를 통해 설정한다.

* **지연 로딩**
  > ![image](https://user-images.githubusercontent.com/96917871/178744696-4deae1a1-5a18-4168-acec-6bf04fa10016.png)
  > 
  > * 하나이상의 객체를 품고 있는 객체를 로딩할때(get) 실제 품고있는 객체들은 실제 객체가 아닌 **프록시 객체**로 생성되어 로딩된다. 실제 프록시 객체가 사용될때 실제 객체를 찾아 연결시켜준다.(초기화 요청)!!, 프록시 객체가 사용되어 질때 JPA가 SQL문을 따로 만들어 DB에 전송 
  > *  ManyToOne(fetch = FetchType.LAZY)"를 통해 설정한다.

**❗주의**
  * 지연로딩만 사용하기(가급적)
  * 즉시 로딩을 적용하면 예상하지 못한 SQL양이 발생 
    > 연관관계가 많은 객체를 가져오는 상황에서 연관관계로 이어진 객체들을 모두 즉시 로딩 해야되기 때문에 많은 양의 SQL문이 발생한다.
  * 즉시 로딩은 JPQL에서 **N+1** 문제를 일으킨다.
    > 1. JPQL에서 일반 조인 같은 경우에는 연관된 엔티티를 같이 조회하지 않음(SQL문을 보내지 않음)
    > 2. 연관된 엔티티 사용시 연관된 엔티티수 만틈 쿼리문 발생 <- 엔티티에 "fetch= = FetchType.LAZY" 설정시 , "EAGER"로 설정한다고 해도 연관 엔티티 개수 만큼 쿼리문 발생(즉시) 
    > 3. "JPQL의 SQL문 한개" + "연관관계가 맺어진 N개의 SQL문"이 발생하게 됨, 연관된 엔티티를 가져오기 위해서 많은 SQL문이 발생하여 성능이 저하됨 
    > 
    >   -> 연관된 엔티티를 즉시 로딩하나 필요시 로딩하나 연관 엔티티 수만큼 쿼리문이 발생하는건 마찬가지!
    >   
    >   => 이러한 문제를 대부분 **페치 조인**으로 해결(연관된 엔티티를 가져오기 위해서 **하나의 쿼리문**을 생성, 최적화 가능)
   
  * @ManyToOne, @OneToOne은 기본이 즉시 로딩, @OneToMany, @ManyToMany는 기본이 지연 로딩



  
