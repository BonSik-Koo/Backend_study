📌 페치 조인
========================================
> * DB의 SQL의 조인 종류가 아님, JPQL에서 **성능 최적화**를 위해서 사용
> * 연관된 **1.엔티티** or **2.컬렉션**을 하나의 SQL문으로 조회 가능 기능
> * "join fetch"(내부 조인), "left join fetch"(외부 조인) 명령어로 사용

**1. 엔티티 페치 조인**
----------------------------
> * 엔티티를 조회하면 연관된 엔티티도 한번에 조회(SQL한번에)
> * 다대일 관계("@ManyToOne") 쪽의 객체를 중심으로 페치 조인함 
>   1. SQL문의 결과로 엔티티 하나당 연관된 엔티티 하나가 매핑 
>   2. DB결과가 뻥튀기 되지 않음

* 엔티티에 직접 적용하는 글로벌 로딩 전략(fetch=FetchType.LAZY 등) 보다 우선시 함
  > ![image](https://user-images.githubusercontent.com/96917871/179017131-978ad961-2754-4a7a-b1bf-757914bb27e8.png)
  > 
  > * "join fetch"를 통해서 엔티티와 연관된 엔티티를 하나의 쿼리문으로 생성
  > * **RANGE** 와 같이 글로벌 로딩 전략으로 설정하면 연관객체를 사용시점에 쿼리문이 날라가지만 **join fetch 가 우선**시 되기 때문에 엔티티를 조회할때 한번에 연관객체도 조회하여 영속성 컨텍스트에 올려둔다. 
  > * 만약 **일반 join**을 사용하게 되면 기본적으로 연관된 엔티티를 조회하지 않지만 **글로벌 로딩 전략**에 따라 연관객체의 로딩을 결정


**2. 컬렉션 페치 조인**
-------------------------------------
> * 일대다("@OneToMany") 쪽의 객체를 중심으로 페치 조인함(양방향으로 연결됨) 
>   1. SQL문의 결과로 엔티티 하나당 연관된 중복된 엔티티가 발생할수 있음 
>   2. DB결과가 뻥튀기 될수 있다. 
>   
> * 일대다의 관계에는 컬렉션에 기본적으로 글로벌 로딩 전략이 "LAZY"이다.
>   1. **페치 조인**을 사용하게 되면 글로벌 로딩 전략 보다 우선시 되기 때문에 엔티티를 검색할때 연관된 엔티티를 하나의 쿼리로 생성
>   2. **일반 조인** 을 사용하게 되면 글로벌 로딩 전략에 따라 동작

**❗ 페치 조인의 특징과 한계**
------------------------------------
* 페치 조인 대상에는 별칭을 줄 수 없다.(할수는 있지만 가급적 사용xx)
* 둘 이상의 컬렉션은 페치 조인할수 없다.
* 컬렉션을 페치 조인하면 페이징(setFirstResult, setMaxResults)를 사용할 수 없다.
  > * DB의 결과로 뻥튀기가 될 수 있기 때문에
  > * 일대다, 다대일 같은 경우에는 페치 조인해도 페이징 가능 -> 가급적 해당 관계로 페이징 사용하기
* 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
* 실무에서 글로벌 로딩 전략은 모두 지연 로딩 -> 성능 최적화가 필요한 곳은 페치 조인 사용하기!
* **페치 조인은 모든 연관객체를 가져와 엔티티 모양그대로 검색할때** 사용하는 것이다. 그렇기 때문에 특정 조건에 만족하는 데이터들에 대해서 페치조인해서는 사용하면 안된다.!! 
   > 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 "DTO"로 만들어 반환하는것이 효과적이다.




